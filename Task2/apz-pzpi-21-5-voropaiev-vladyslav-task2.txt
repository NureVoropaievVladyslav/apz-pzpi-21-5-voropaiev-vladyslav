1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Розроблювана програмна система має в своєму основі архітектуру, що складається з п'яти шарів. Ця структура ґрунтується на концепціях предметно-орієнтованого проєктування, що передбачає використання об'єктно-орієнтованого підходу до розробки системи з орієнтацією на доменну модель проблемної області.
Перший шар, або рівень домену, є найближчим до проблемної області програмної системи. У цьому шарі розміщуються сутності, виключення, об'єкти значень та перелічення, які відображають ключові або основні аспекти риборозплідних ставів та їх управління.
Другий рівень, або рівень застосунку, включає поведінкові класи, команди, запити та інтерфейси, які взаємодіють з сутностями з шару домену. У цьому рівні знаходяться класи, що реалізують бізнес-логіку програми та відповідають за обробку запитів користувача або системних подій. Поведінкові класи визначають способи взаємодії між об'єктами доменного рівня, а також виконують операції, необхідні для досягнення поставлених завдань. Команди та запити використовуються для передачі дій до доменного рівня, де вони інтерпретуються та виконуються. Інтерфейси забезпечують взаємодію користувача або зовнішніх систем з додатком, дозволяючи їм взаємодіяти з сутностями та функціями, що надаються програмною системою.
Третій рівень, або рівень інфраструктури, включає в себе компоненти, необхідні для забезпечення функціональності програмної системи. Сюди входять база даних, міграції, конфігурації, класи, що відповідають за авторизацію та автентифікацію користувачів, а також реалізацію інтерфейсів попереднього рівня. База даних використовується для зберігання інформації про риборозплідні стави, їх стан та інші важливі дані. Міграції використовуються для керування структурою бази даних та забезпечення її сумісності з новими версіями програми. Конфігурації визначають параметри та налаштування системи. Класи авторизації та автентифікації відповідають за перевірку прав доступу користувачів до різних частин системи. Реалізація інтерфейсів забезпечує комунікацію між цим рівнем та рівнем застосунку.
Четвертий рівень, рівень презентації, включає контролери для обробки HTTP запитів, налаштування програми, контейнер внедрення залежностей та проміжне програмне забезпечення. Контролери для обробки HTTP запитів відповідають за приймання вхідних запитів від клієнтів та виклик відповідних функцій або сервісів для їх обробки. Налаштування програми визначають параметри та конфігурації, необхідні для правильної роботи програми в різних середовищах. Контейнер внедрення залежностей використовується для управління залежностями та ін'єкції залежностей в об'єкти в рамках програми. Проміжне програмне забезпечення використовується для обробки запитів перед їх подальшою обробкою контролерами або після їх обробки для виконання додаткових дій, таких як логування, аутентифікація, авторизація тощо. 
Додатковим шаром є шар ресурсів, який містить в собі інформацію для глобалізації. Цей шар включає тексти, переклади та інші ресурси, які використовуються для адаптації програмного забезпечення до різних мов та культурних контекстів. Тут зберігаються рядки для інтерфейсу користувача, повідомлення про помилки, формати дат та часу, валюти та інші локалізовані дані, що дозволяють програмі взаємодіяти з користувачами у різних країнах та регіонах.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Розроблювана система інтегрує в себе різноманітні компоненти, що охоплюють серверну частину, веб-додаток, мобільний додаток та розумний пристрій. Ця комплексна архітектура сприяє широкому охопленню користувачів і дозволяє забезпечити високий рівень доступності та зручності взаємодії. Відображення компонентів системи на діаграмі розгортання (див. рис. 2.1) надає зрозумілу візуальну репрезентацію їх взаємозв'язків та розміщення, що є важливим для ефективного управління та розгортання системи.

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

3.1 Створення бази даних та робота з даними
Для реалізації бази даних системи був обраний підхід Entity Framework «Code First», що передбачає автоматичне створення структури бази даних на основі класів, описаних у програмному коді, за допомогою міграцій. У доменному шарі була спеціально створена папка з назвою «Entities», де були описані сутності бази даних.
Цей підхід дозволяє зосередитися на програмуванні логіки додатку, не втрачаючи часу на вручну створення та оновлення схеми бази даних. Замість цього, ми можемо просто створювати та змінювати класи, які відображають структуру даних, а система Entity Framework відповідно створює або мігрує базу даних, використовуючи ці класи як вихідний шаблон.
Було створено базовий клас дозволяє спадкувати загальні властивості для всіх сутностей у системі, що допомагає уникнути дублювання коду та спрощує управління часовими мітками та ідентифікацією записів:
1. /// <summary>
2. /// Represents a base entity with common properties.
3. /// </summary>
4. public class BaseEntity
5. {
6.     /// <summary>
7.     /// Gets or sets the unique identifier of the entity.
8.     /// </summary>
9.     public Guid Id { get; set; }
10.         
11.     /// <summary>
12.     /// Gets or sets the date and time when the entity was created, in UTC.
13.     /// </summary>
14.     public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
15. }
Для роботи з базою даних у проекті було використано Entity Framework, а система управління базами даних PostgreSQL обрана як оптимальне рішення для потреб проекту. Після успішного налаштування бази даних було впроваджено шаблон «Репозиторій», який використовується для ізоляції бізнес-логіки від деталей роботи з даними. Цей підхід дозволяє зберігати та отримувати дані без прямого залучення у рівні бізнес-логіки, забезпечуючи кращу модульність та масштабованість системи. Спочатку були створені інтерфейси, які визначають методи, що будуть реалізовані у відповідному класі репозиторію, зокрема, прикладами є інтерфейси IRepository<T> та IUnitOfWork. Цей підхід дозволяє забезпечити єдність і структурованість управління даними та робить код більш читабельним та легким для розуміння та підтримки. Код інтерфейсу IRepository<T> можна знайти в додатку А.
3.2 Використання CQRS, MediatR та контролерів
Для реалізації патерна CQRS (Command Query Responsibility Segregation) та керування запитами та командами у системі використовувався NuGET пакет MediatR. Цей пакет надає простий та ефективний механізм для обробки запитів та команд у додатку. Завдяки MediatR, реалізація патерна CQRS стала більш зручною та прозорою, що сприяє полегшенню розробки та підтримки системи.
У шарі додатку були створені класи запитів та команд, які відповідають за представлення оброблюваних запитів та команд системи. Ці класи відображають конкретні дії, які потрібно виконати в системі, і включають у себе необхідні дані для їх виконання. Крім того, вони забезпечують розділення логіки запитів та команд, що сприяє підтримці принципів чистої архітектури та розбиття системи на логічні компоненти.
Використання класів запитів та команд у шарі додатку дозволяє забезпечити чітку структуру та розділення відповідальностей між частинами системи. Це дозволяє зробити код більш читабельним, модульним та легко зрозумілим для інших розробників. Такий підхід сприяє полегшенню розвитку та підтримки програмного забезпечення, а також підвищує його якість та надійність.
Приклад команди для реєстрації в системі користувача:
1. public record RegisterWorkerCommand(string FullName, string Username, string Email, string Password) : IRequest<string>;
Для кожної команди та запиту в системі було створено відповідний обробник та клас, який відповідає за перевірку та верифікацію даних, що надходять. Цей підхід дозволяє розділити логіку обробки запитів та команд від логіки перевірки та валідації даних, що забезпечує кращу читабельність та масштабованість системи. Деякі запити потребували спеціального обробника для виконання певних дій або операцій над даними, тому було створено відповідні обробники, які забезпечують цю функціональність.
1. public sealed class RegisterWorkerCommandHandler : IRequestHandler<RegisterWorkerCommand, string>
2. {
3.     private readonly IUnitOfWork _unitOfWork;
4.     private readonly IUserRepository _userRepository;
5.     private readonly IMapper _mapper;
6. 
7.     public RegisterWorkerCommandHandler(IUnitOfWork unitOfWork, IUserRepository userRepository, IMapper mapper)
8.     {
9.         _unitOfWork = unitOfWork;
10.         _userRepository = userRepository;
11.         _mapper = mapper;
12.     }
13. 
14.     public async Task<string> Handle(RegisterWorkerCommand request, CancellationToken cancellationToken)
15.     {
16.         var user = _mapper.Map<User>(request);
17.         var token = await _userRepository.RegisterUserAsync(user, request.Password, cancellationToken);
18.         await _unitOfWork.SaveChangesAsync(cancellationToken); 
19.         return token;
20.     }
21. }
Додатково, для деяких запитів було створено відповідні профілі, які відповідають за перетворення команд до сутностей доменного шару. Ці профілі дозволяють узагальнити логіку перетворення даних та забезпечити їх правильність та цільову орієнтацію для використання у різних частинах системи. Такий підхід спрощує розробку та підтримку системи, оскільки дозволяє уникнути дублювання коду та забезпечити єдність логіки обробки даних.
1. public class RegisterWorkerCommandProfile : Profile
2. {
3.     public RegisterWorkerCommandProfile()
4.     {
5.         CreateMap<RegisterWorkerCommand, User>();
6.     }
7. }
Кожен контролер у системі був ретельно розроблений для обробки HTTP-запитів, що стосуються конкретної сутності. Ці контролери функціонували як посередники між клієнтом та серверною частиною додатку, забезпечуючи взаємодію із системою через HTTP-протокол. Кожен контролер відповідав за виконання різних операцій, таких як отримання даних, створення нових записів, оновлення та видалення існуючих даних.
Кожен запит або команда, що надходила до контролера, передавалася до відповідного обробника запитів або команд для подальшої обробки. Ці обробники відповідали за виконання конкретних дій відповідно до отриманих від контролера інструкцій. Після завершення обробки запиту або команди результат повертався назад до контролера, який забезпечував передачу відповіді клієнту.
Приклад контролера, що відповідає за роботу з даними користувачів наведено в додатку Б.
3.3 Обробка помилок
Для ефективного управління винятками у системі було розроблено проміжне програмне забезпечення для обробки винятків, яке відповідає за перехоплення та обробку помилок під час виконання запитів. Це ExceptionHandlingMiddleware дозволяє системі гнучко реагувати на можливі виняткові ситуації та надавати можливість відновлення нормальної роботи додатку після виникнення помилок.
ExceptionHandlingMiddleware було інтегровано у систему як частину загальної архітектури обробки запитів, що дозволяло йому працювати з іншими компонентами системи у взаємодії. Це забезпечувало однорідність у реагуванні на помилки та підтримувало стабільність та надійність системи в цілому. Програмний код цього класу наведено в додатку В.
3.4 Бізнес логіка
Бізнес-логіка системи зосереджена на керуванні та оптимізації роботи з риборозплідними ставами. Головною функціональністю є створення ставів та ефективне керування їхніми даними. Клас репозиторію, який відповідає за основні дії над даними системи можна знайти в додатку Г.
Керування даними ставів включає в себе моніторинг та збір інформації про стан ставів, таку як температура води, рівень кисню, кількість та розподіл риби тощо. Ця інформація використовується для аналізу та прийняття рішень щодо оптимальних умов утримання риби, а також для планування майбутніх заходів щодо покращення управління ставами.
Бізнес-логіка системи також передбачає автоматизацію деяких процесів, таких як годівля риби, контроль рівня води в ставах, виявлення та вирішення потенційних проблем, що можуть виникнути у процесі експлуатації ставів. Це допомагає забезпечити ефективне та стабільне управління риборозплідними ставами з мінімальними втратами та оптимізацією виробничих процесів.
У системі застосовуються математичні методи для обробки різноманітних даних, спрямованих на оптимізацію умов утримання риби та підтримання їхнього здоров'я. Наприклад, для визначення оптимальної кількості їжі, необхідної для риб, і встановлення інтервалу годування застосовуються відповідні розрахунки, що базуються на параметрах, таких як вага риби, температура води та її хімічний склад.
Додатково, в системі реалізовані функціональності для конвертації температурних даних, об'єму їжі та рівня розчиненого аміаку до різних одиниць виміру. Наприклад, конвертація температури з градусів Цельсія до Фаренгейта, або перетворення ваги з кілограмів до фунтів. Ці обчислення дозволяють користувачам працювати з даними у форматі, який є більш зрозумілим або зручним для них, сприяючи зручності та ефективності використання системи. Такий підхід допомагає забезпечити точність та зрозумілість обробки даних у системі, що є важливим фактором для успішної експлуатації риборозплідних ставів.
3.5 Можливість адміністрування системи
Адміністраторам системи доступний широкий спектр функцій для керування системою. Головні можливості включають управління користувачами, що охоплює їх створення, видалення, перегляд та зміну ролей. Крім того, доступні інструменти для імпорту та експорту даних користувачів, що спрощує процес управління та забезпечує зручність у роботі з інформацією. 
Також адміністраторам надається можливість управління інформацією про стави та відповідні графіки годування. Це включає створення, редагування, видалення та імпорт/експорт даних, що дозволяє забезпечити точне та зручне управління риборозплідними ставами та пов'язаною з ними інформацією.
3.6 Локалізація
Для забезпечення багатомовності та локалізації програми систематично використовуються файли ресурсів. Цей підхід забезпечує зручність та доступність для користувачів з різних країн та мовних середовищ, оскільки дозволяє відображати текст та інші елементи у відповідності з обраною мовою.
Кожен файл ресурсів створюється з урахуванням конкретної мови та містить переклади текстів програми на цю мову. Таким чином, наявність відповідних файлів ресурсів для англійської та української мов гарантує, що користувачі можуть сприймати інтерфейс додатку мовою, зрозумілою для них.
Наприклад клас перевірки коректності даних команди реєстрації користувача, який виконує важливу роль у забезпеченні правильного та безперервного функціонування системи. Цей клас відповідає за перевірку введених користувачем даних на відповідність заданим критеріям, що є важливою складовою у забезпеченні цілісності та безпеки інформації.
Одним із ключових аспектів роботи цього класу є локалізація повідомлень про некоректні дані. Це означає, що система може надати користувачеві інформативне повідомлення про помилку на його рідній мові, що покращує взаєморозуміння та забезпечує зручність у використанні програми.
Наприклад, якщо користувач введе некоректний електронний адрес або пароль, клас валідації команди реєстрації користувача може вивести відповідне повідомлення про помилку, яке буде відображено на мові, встановленій в налаштуваннях програми. Цей підхід допомагає покращити взаємодію користувачів з програмним забезпеченням та забезпечує більш якісне та приємне використання системи. Код цього класу наведено в додатку Д.
3.7 Інтернаціоналізація
Інтернаціоналізація в системі також презентацію даних у різних одиницях виміру, зокрема температури, кількості їжі та рівня аміаку. Це означає, що користувачі з різних країн можуть бачити ці дані у вимірах, зрозумілих для них, що забезпечує зручність та зрозумілість інформації.
Наприклад, температура може відображатися в градусах Цельсія або Фаренгейта в залежності від вибору користувача. Крім того, кількість їжі може представлятися в кілограмах та фунтах, а рівень аміаку - у міліграмах на літр та фунтах на унцію. Приклад методу, який повертає відповідні дані наведено в додатку Е.
3.8 Облік часу
Облік часу у системі ведеться в форматі UTC (Coordinated Universal Time) з урахуванням часового поясу. Це стандартизований глобальний час, який не залежить від географічного положення. Використання UTC дозволяє забезпечити консистентність та точність відображення часових даних у всіх частинах світу, незалежно від місцевого часу. Крім того, система може автоматично адаптуватися до змін часового поясу, забезпечуючи коректне відображення часу під час переміщень користувачів або змін у часових поясах. Такий підхід до обліку часу сприяє уникненню плутанини і забезпечує коректне відображення подій та даних у системі.
3.9 Захист даних
Захист даних у системі є пріоритетною задачею, і для цього використовуються різноманітні заходи безпеки. Один із основних методів - це використання JWT (JSON Web Token) для аутентифікації та авторизації користувачів. JWT дозволяє надійно передавати дані про авторизованого користувача між клієнтом та сервером, забезпечуючи захист від підроблення даних і підміни ідентифікаторів.
Крім того, для забезпечення безпеки під час передачі даних через мережу використовується протокол HTTPS (Hypertext Transfer Protocol Secure), який забезпечує шифрування та захист від перехоплення чутливої інформації, такої як паролі або особисті дані.
У базі даних вразлива інформація, така як паролі або особисті дані користувачів, зберігається у закодованому вигляді. Кодування дозволяє перетворити чутливу інформацію в незрозумілу послідовність символів, яка важко піддається розшифруванню навіть у випадку незаконного доступу до бази даних.
Всі ці заходи безпеки разом забезпечують надійний захист даних у системі, зменшуючи ризик несанкціонованого доступу або витоку конфіденційної інформації.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Функціональні можливості, які були визначені у документі Vision & Scope для розробки серверної частини системи, були агреговані та представлені у вигляді діаграми прецедентів (див. рис. 4.1). У цій системі існують три основних актори: незареєстрований користувач, працівник та адміністратор. Кожен з цих акторів виконує свої унікальні ролі та має доступ до визначених функціональних можливостей, що забезпечують широкий спектр можливостей та взаємодії з системою. Діаграма прецедентів надає зрозуміле візуальне представлення цих можливостей та взаємозв'язків між ними, що сприяє кращому розумінню та управлінню функціональними вимогами системи.

5 ПОБУДОВА ER-ДІАГРАМИ

Після аналізу системи було створено ER-діаграму бази даних для наочного відображення структури та зв'язків між різними сутностями. База даних складається з трьох основних таблиць: «Користувачі» («Users»), «Стави» («Ponds») та «Графіки годування» («FeedingSchedules»). Кожна таблиця має свій власний унікальний ідентифікатор в якості первинного ключа, що дозволяє однозначно ідентифікувати кожен запис.
Для створення ER-діаграми були визначені основні сутності та їх атрибути, а також зв'язки між ними. У процесі моделювання були враховані потреби системи та вимоги до зберігання та обробки даних. Результатом цього аналізу стала чітка структура бази даних, яка відображає основні об'єкти та взаємозв'язки між ними, що відображено на ER-діаграмі.

6 СПЕЦИФІКАЦІЯ REST

REST API системи для управління риборозплідними ставами містить 17 ендпоінтів, що дозволяють взаємодіяти з різними аспектами системи. Специфікація REST API та опис кожного ендпоінту наведений у таблиці 1. Рівні доступу до цих ендпоінтів включають неавторизованих користувачів, працівників та адміністраторів, які мають доступ до системи.
Таблиця 6.1 – Специфікація REST API
Рівень доступу	Посилання на ендпоінт	HTTP-метод	Призначення
Всі	/api/Users/login	POST	Реєстрація користувача
Всі	/api/Users/login                    	POST            	Авторизація користувача
Адміністратор        	/api/Users                         	GET             	Отримання списку користувачів
Адміністратор        	/api/Users              	DELETE          	Видалення користувача
Працівник        	/api/Users/Update	PUT             	Оновлення даних користувача
Адміністратор        	/api/Users/make-admin                   	POST            	Надання статусу адміністратора
Адміністратор	/api/Users/export	GET             	Експорт даних користувачів
Рівень доступу	Посилання на ендпоінт	HTTP-метод	Призначення
Адміністратор	/api/Users/import	POST            	Імпорт даних користувачів
Працівник        	/api/FeedingSchedules 	POST            	Створення графіку годування
Працівник        	/api/FeedingSchedules 	PUT             	Оновлення графіку годування
Адміністратор        	/api/FeedingSchedules 	DELETE          	Видалення графіку годування
Адміністратор        	/api/FeedingSchedules/export	GET             	Експорт даних графіків годування
Адміністратор        	/api/FeedingSchedules/import	POST            	Імпорт даних графіків годування
Авторизований        	/api/Ponds 	POST            	Створення ставу
Авторизований        	/api/Ponds 	GET             	Отримання даних про став
Адміністратор        	/api/Ponds/export	GET             	Експорт даних про став
Адміністратор        	/api/Ponds/import	POST            	Імпорт даних про став

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Для створення діаграми компонентів спочатку проведено детальний аналіз системи, під час якого були ідентифіковані основні компоненти та їх взаємозв'язки. На основі цього аналізу було розібрано систему на окремі логічні компоненти, які відповідають за різні частини функціональності.
Після ідентифікації основних компонентів системи було вирішено розмістити їх у відповідних пакетах та шарах архітектури. Це дозволило логічно та структурно організувати компоненти системи та визначити їх взаємозв'язки.
В процесі створення діаграми були враховані не лише функціональні аспекти системи, а й її архітектурні принципи та вимоги до розгортання. Це дозволило побудувати діаграму компонентів, яка відображає не лише логічну структуру системи, а й її фізичну організацію та взаємозв'язки між компонентами.

ВИСНОВКИ

Під час виконання цієї лабораторної роботи була розроблена серверна частина проекту. Були створені діаграми діаграмах розгортання (Deployment Diagram), прецедентів (Use Case Diagram), ER-модель даних (Entity–Relationship Model) та UML діаграмі пакетів (Package Diagram). Було спроектовано та розроблено БД. Було розроблено та наведено таблицю специфікації REST API. 

ДОДАТОК А

Код інтерфейсу IRepository<T>
1. /// <summary>
2. /// Represents a generic repository interface for CRUD operations on entities.
3. /// </summary>
4. /// <typeparam name="T">The type of entity.</typeparam>
5. public interface IRepository<T> where T : BaseEntity
6. {
7.     /// <summary>
8.     /// Asynchronously creates a new entity.
9.     /// </summary>
10.     /// <param name="entity">The entity to create.</param>
11.     /// <param name="cancellationToken">The cancellation token.</param>
12.     Task CreateAsync(T entity, CancellationToken cancellationToken);
13. 
14.     /// <summary>
15.     /// Updates an existing entity.
16.     /// </summary>
17.     /// <param name="entity">The entity to update.</param>
18.     void Update(T entity);
19. 
20.     /// <summary>
21.     /// Deletes an entity.
22.     /// </summary>
23.     /// <param name="entity">The entity to delete.</param>
24.     void Delete(T entity);
25. 
26.     /// <summary>
27.     /// Asynchronously retrieves an entity by its unique identifier.
28.     /// </summary>
29.     /// <param name="id">The unique identifier of the entity.</param>
30.     /// <param name="cancellationToken">The cancellation token.</param>
31.     /// <returns>The retrieved entity, or null if not found.</returns>
32.     Task<T?> GetAsync(Guid id, CancellationToken cancellationToken);
33. 
34.     /// <summary>
35.     /// Asynchronously retrieves all entities.
36.     /// </summary>
37.     /// <param name="cancellationToken">The cancellation token.</param>
38.     /// <returns>A list of entities.</returns>
39.     Task<List<T>> GetAsync(CancellationToken cancellationToken);
40. 
41.     /// <summary>
42.     /// Gets a queryable representation of entities for advanced querying.
43.     /// </summary>
44.     /// <returns>An IQueryable representing the entities.</returns>
45.     IQueryable<T> GetQueryable();
46. 
47.     /// <summary>
48.     /// Exports entities to JSON asynchronously.
49.     /// </summary>
50.     /// <param name="cancellationToken">Cancellation token.</param>
51.     /// <returns>A task representing the asynchronous operation. The task result contains the JSON data.</returns>
52.     Task<string> ExportToJsonAsync(CancellationToken cancellationToken);
53. 
54.     /// <summary>
55.     /// Imports entities from JSON asynchronously.
56.     /// </summary>
57.     /// <param name="json">JSON string containing the entities.</param>
58.     /// <param name="cancellationToken">Cancellation token.</param>
59.     /// <returns>A task representing the asynchronous operation. The task result contains a collection of imported entities.</returns>
60.     Task<ICollection<T>> ImportFromJsonAsync(string json, CancellationToken cancellationToken);
61. }

ДОДАТОК Б

Код класу контролеру користувачів IRepository<T>
1. [Route("api/[controller]")]
2. [ApiController]
3. public class UsersController : ControllerBase
4. {
5.     private readonly IMediator _mediator;
6.
7.     public UsersController(IMediator mediator)
8.     {
9.         _mediator = mediator;
10.     }
11. 
12.     [HttpPost("login")]
13.     public async Task<ActionResult> Login(LoginQuery request, CancellationToken cancellationToken)
14.     {
15.         var response = await _mediator.Send(request, cancellationToken);
16.         return Ok(response);
17.     }
18.     
19.     [HttpPost("register")]
20.     public async Task<ActionResult> Create(RegisterWorkerCommand request, CancellationToken cancellationToken)
21.     {
22.         var response = await _mediator.Send(request, cancellationToken);
23.         return Ok(response);
24.     }
25. 
26.     [Authorize(Roles = nameof(Role.Admin))]
27.     [HttpGet]
28.     public async Task<ActionResult> Get(CancellationToken cancellationToken)
29.     {
30.         var response = await _mediator.Send(new GetAllUsersQuery(), cancellationToken);
31.         return Ok(response);
32.     }
33.     
34.     [Authorize(Roles = nameof(Role.Admin))]
35.     [HttpDelete]
36.     public async Task<ActionResult> Delete([FromQuery] Guid userId, CancellationToken cancellationToken)
37.     {
38.         var response = await _mediator.Send(new DeleteUserCommand(userId), cancellationToken);
39.         return Ok(response);
40.     }
41. 
42.     [Authorize(Roles = nameof(Role.Admin))]
43.     [HttpPost("make-admin")]
44.     public async Task<ActionResult> MakeAdmin([FromQuery] Guid userId, CancellationToken cancellationToken)
45.     {
46.         var response = await _mediator.Send(new MakeAdminCommand(userId), cancellationToken);
47.         return Ok(response);
48.     }
49. 
50.     [Authorize]
51.     [HttpPut]
52.     public async Task<ActionResult> Update(UpdateUserCommand request, CancellationToken cancellationToken)
53.     {
54.         var response = await _mediator.Send(request, cancellationToken);
55.         return Ok(response);
56.     }
57. }

ДОДАТОК В

Код класу ExceptionHandlingMiddleware
1. public class ExceptionHandlingMiddleware
2. {
3.     private readonly RequestDelegate _next;
4.     private readonly ILogger<ExceptionHandlingMiddleware> _logger;
5. 
6.     public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)
7.     {
8.         _next = next;
9.         _logger = logger;
10.     }
11. 
12.     public async Task InvokeAsync(HttpContext context)
13.     {
14.         try
15.         {
16.             await _next(context);
17.         }
18.         catch (ExceptionBase ex)
19.         {
20.             _logger.LogError(ex, ex.Message);
21. 
22.             context.Response.StatusCode = (int)ex.HttpStatusCode;
23. 
24.             var problem = new ProblemDetails()
25.             {
26.                 Status = (int)ex.HttpStatusCode,
27.                 Type = ex.HttpStatusCode.ToString(),
28.                 Detail = ex.Message
29.             };
30. 
31.             string problemJson = JsonSerializer.Serialize(problem);
32.             context.Response.ContentType = "application/json";
33.             await context.Response.WriteAsync(problemJson);
34.         }
35.     }
36. }

ДОДАТОК Д

Код класу RegisterWorkerCommandValidator
1. public class RegisterWorkerCommandValidator : AbstractValidator<RegisterWorkerCommand>
2. {
3.     public RegisterWorkerCommandValidator()
4.     {
5.         RuleFor(x => x.FullName)
6.             .NotEmpty().WithMessage(Resource.RequiredField)
7.             .MinimumLength(8).WithMessage(Resource.FullNameMustBeEightCharacters);
8. 
9.         RuleFor(x => x.Email)
10.             .NotEmpty().WithMessage(Resource.RequiredField)
11.             .EmailAddress().WithMessage(Resource.EmailNotValid);
12.         
13.         RuleFor(x => x.Username)
14.             .NotEmpty().WithMessage(Resource.RequiredField)
15.             .MinimumLength(5).WithMessage(Resource.UsernameMustBeFiveCharacters)
16.             .Matches("[a-z]+$").WithMessage(Resource.UsernameMustContainOnlyLowercase);
17. 
18.         RuleFor(x => x.Password)
19.             .NotEmpty().WithMessage(Resource.RequiredField)
20.             .MinimumLength(8).WithMessage(Resource.PasswordBoundaries)
21.             .MaximumLength(32).WithMessage(Resource.PasswordBoundaries)
22.             .Matches(@"[A-Z]+").WithMessage(Resource.PasswordCharacters)
23.             .Matches(@"[a-z]+").WithMessage(Resource.PasswordCharacters)
24.             .Matches(@"[0-9]+").WithMessage(Resource.PasswordCharacters)
25.             .Matches(@"[\!\?\*\.]+").WithMessage(Resource.PasswordCharacters);
26.     }
27. }

ДОДАТОК Е

Код методу GetDataAsync
1. public async Task<object> GetDataAsync(Guid pondId, CancellationToken cancellationToken)
2.     {
3.         var dataFromSmartDevice = await _smartDeviceService.GetDataFromPond(pondId);
4.         
5.         var temperatureInCelsius = 
6.             (double)dataFromSmartDevice.GetType().GetProperty("TemperatureInCelcius")!.GetValue(dataFromSmartDevice)!;
7.         var temperatureInFahrenheit = ConvertCelsiusToFahrenheit(temperatureInCelsius);
8. 
9.         var foodAmountInKilos =
10.             (double)dataFromSmartDevice.GetType().GetProperty("FoodAmountInKilos")!.GetValue(dataFromSmartDevice)!;
11.         var foodAmountInPounds = ConvertKilosToPounds(foodAmountInKilos);
12.         
13.         double dissolvedAmmoniaMgL = 
14.             (double)dataFromSmartDevice.GetType().GetProperty("DissolvedAmmoniaMgL")!.GetValue(dataFromSmartDevice)!;
15.         double dissolvedAmmoniaLbsOz = ConvertMgLtoLbsOz(dissolvedAmmoniaMgL);
16.         
17.         dataFromSmartDevice.GetType().GetProperty("TemperatureInFahrenheit")!.SetValue(dataFromSmartDevice, temperatureInFahrenheit);
18.         dataFromSmartDevice.GetType().GetProperty("FoodAmountInPounds")!.SetValue(dataFromSmartDevice, foodAmountInPounds);
19.         dataFromSmartDevice.GetType().GetProperty("DissolvedAmmoniaLbsOz")!.SetValue(dataFromSmartDevice, dissolvedAmmoniaLbsOz);
20. 
21.         return dataFromSmartDevice;
22.     }
